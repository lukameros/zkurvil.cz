<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üíÄ Level 6 - MAN EATER</title>
    <link rel="stylesheet" href="game-style.css">
    <link rel="stylesheet" href="ui.css">
    <script src="ui.js" defer></script>
</head>
<body style="background: radial-gradient(ellipse at center, #2d0a3d, #000000);">
    <div class="coins-header">
        <div class="coins-amount">ü™ô <span id="coinsHeaderDisplay">0</span></div>
        <button class="add-coins-small" onclick="window.location.href='shop.html'">‚ûï</button>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas" class="game-canvas" style="border-color: #a855f7;"></canvas>
        
        <div class="sidebar">
            <div class="role" style="background: linear-gradient(135deg, rgba(139, 92, 246, 0.6), rgba(124, 58, 237, 0.4));">üü£ Level 6</div>
            <div class="score">Sk√≥re: <span id="score">0</span></div>
            <div class="info" id="coins">ü™ô Mince: 0</div>
            <div class="info" id="dotsRemaining">Dots: 0</div>
            <div class="info" id="lives">‚ù§Ô∏è ≈Ωivoty: 3</div>
            
            <div class="controls">
                <h4>Ovl√°d√°n√≠:</h4>
                <p>‚Üê ‚Üí ‚Üë ‚Üì</p>
            </div>

            <button id="exitBtn" class="btn" style="margin-top: 20px;">
                Opustit level
            </button>
        </div>
    </div>

    <div id="gameOver" class="game-over" style="display: none;">
        <h2 id="gameOverTitle"></h2>
        <p id="gameOverScore"></p>
        <p id="gameOverCoins" style="font-size: 2rem; color: #fbbf24;">ü™ô Z√≠sk√°no: <span id="earnedCoins">0</span> minc√≠</p>
        <button id="backToLevelsBtn" class="btn" style="max-width: 300px;">
            Zpƒõt na v√Ωbƒõr level≈Ø
        </button>
    </div>

    <script>
        const TILE_SIZE = 25;
        const LEVEL = 6;
        const WALL_COLOR1 = '#7c3aed'; // Fialov√°
        const WALL_COLOR2 = '#a855f7';
        const WALL_COLOR3 = '#7c3aed';
        
        // St≈ôedn√≠ mapa
        let maze = [
            "##################",
            "#................#",
            "#.###.#####.###.#",
            "#o.............o#",
            "#.###.##.##.###.#",
            "#.....##.##.....#",
            "####.#### ####.####",
            "#...            ...#",
            "#.####.####.####.#",
            "#................#",
            "#.###.######.###.#",
            "#o................o#",
            "##################"
        ];

        // Normalizace mapy (stejn√° ≈°√≠≈ôka ≈ô√°dk≈Ø)
        const MAZE_WIDTH = Math.max(...maze.map(r => r.length));
        maze = maze.map(r => r.padEnd(MAZE_WIDTH, '#'));
        const MAZE_HEIGHT = maze.length;

        // Z√≠sk√°n√≠ dat z localStorage
        function getGameData() {
            return JSON.parse(localStorage.getItem('gameData') || '{"energy":100,"coins":0}');
        }

        function updateCoinsHeader() {
            const data = getGameData();
            document.getElementById('coinsHeaderDisplay').textContent = data.coins || 0;
        }

        class Level3Game {
            constructor() {
                updateCoinsHeader();
                
                const energy = this.getEnergy();
                if (energy < 25) {
                    alert(`‚ùå Nedostatek energie!`);
                    window.location.href = 'levels.html';
                    return;
                }
                
                this.useEnergy(25);
                
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = MAZE_WIDTH * TILE_SIZE;
                this.canvas.height = MAZE_HEIGHT * TILE_SIZE;

                this.score = 0;
                this.coins = 0;
                this.lives = 3;
                this.gameOver = false;
                this.animationFrame = 0;

                this.pacman = { 
                    x: 1, 
                    y: 1, 
                    direction: { x: 0, y: 0 },
                    nextDirection: { x: 0, y: 0 },
                    mouthAngle: 0.2,
                    mouthOpen: true
                };
                
                // 3 duchov√©
                this.ghosts = [
                    { x: 8, y: 6, color: '#FF0000', direction: { x: 0, y: 0 }, animOffset: 0 },
                    { x: 9, y: 6, color: '#FFB8FF', direction: { x: 0, y: 0 }, animOffset: 20 },
                    { x: 10, y: 6, color: '#00FFFF', direction: { x: 0, y: 0 }, animOffset: 40 }
                ];
                
                this.dots = [];
                this.powerPellets = [];
                this.powerMode = false;
                this.powerTimer = 0;

                this.initMaze();
                this.setupControls();
                this.startGame();

                document.getElementById('exitBtn').addEventListener('click', () => {
                    window.location.href = 'levels.html';
                });

                document.getElementById('backToLevelsBtn').addEventListener('click', () => {
                    window.location.href = 'levels.html';
                });
            }

            getEnergy() {
                const data = getGameData();
                const now = Date.now();
                const hoursPassed = (now - (data.lastEnergyUpdate || 0)) / (1000 * 60 * 60);
                const regenAmount = Math.floor(hoursPassed / 4) * 100;
                
                return Math.min(100, data.energy + regenAmount);
            }

            useEnergy(amount) {
                const data = getGameData();
                data.energy = Math.max(0, data.energy - amount);
                data.lastEnergyUpdate = Date.now();
                localStorage.setItem('gameData', JSON.stringify(data));
            }

            initMaze() {
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[y].length; x++) {
                        if (maze[y][x] === '.') {
                            this.dots.push({ x, y });
                        } else if (maze[y][x] === 'o') {
                            this.powerPellets.push({ x, y });
                        }
                    }
                }
                this.updateDotsDisplay();
            }

            setupControls() {
                document.addEventListener('keydown', (e) => {
                    if (this.gameOver) return;
                    if (e.key === 'ArrowLeft') this.pacman.nextDirection = { x: -1, y: 0 };
                    if (e.key === 'ArrowRight') this.pacman.nextDirection = { x: 1, y: 0 };
                    if (e.key === 'ArrowUp') this.pacman.nextDirection = { x: 0, y: -1 };
                    if (e.key === 'ArrowDown') this.pacman.nextDirection = { x: 0, y: 1 };
                });
            }

            startGame() {
                setInterval(() => {
                    if (!this.gameOver) {
                        this.animationFrame++;
                        this.update();
                        this.draw();
                    }
                }, 100);
            }

            update() {
                this.movePacman();
                this.checkDotCollision();
                
                if (this.animationFrame % 3 === 0) {
                    this.pacman.mouthOpen = !this.pacman.mouthOpen;
                    this.pacman.mouthAngle = this.pacman.mouthOpen ? 0.2 : 0.05;
                }
                
                for (const ghost of this.ghosts) {
                    this.moveGhostAI(ghost);
                }
                
                if (this.powerMode) {
                    this.powerTimer--;
                    if (this.powerTimer <= 0) this.powerMode = false;
                }
                
                this.checkGhostCollision();
            }

            movePacman() {
                const nextX = this.pacman.x + this.pacman.nextDirection.x;
                const nextY = this.pacman.y + this.pacman.nextDirection.y;
                
                if (this.isWalkable(nextX, nextY)) {
                    this.pacman.direction = { ...this.pacman.nextDirection };
                }

                const newX = this.pacman.x + this.pacman.direction.x;
                const newY = this.pacman.y + this.pacman.direction.y;

                if (this.isWalkable(newX, newY)) {
                    this.pacman.x = newX;
                    this.pacman.y = newY;
                }
            }

            moveGhostAI(ghost) {
                const directions = [
                    { x: -1, y: 0 }, { x: 1, y: 0 },
                    { x: 0, y: -1 }, { x: 0, y: 1 }
                ];

                if (Math.random() < 0.25 || this.powerMode) {
                    const validDirs = directions.filter(dir => {
                        return this.isWalkable(ghost.x + dir.x, ghost.y + dir.y);
                    });
                    
                    if (validDirs.length > 0) {
                        const randomDir = validDirs[Math.floor(Math.random() * validDirs.length)];
                        ghost.x += randomDir.x;
                        ghost.y += randomDir.y;
                        ghost.direction = randomDir;
                    }
                    return;
                }
                
                const target = { x: this.pacman.x, y: this.pacman.y };
                let bestDir = ghost.direction;
                let bestDist = Infinity;

                for (const dir of directions) {
                    if (dir.x === -ghost.direction.x && dir.y === -ghost.direction.y) continue;
                    
                    const newX = ghost.x + dir.x;
                    const newY = ghost.y + dir.y;

                    if (this.isWalkable(newX, newY)) {
                        const dist = Math.abs(target.x - newX) + Math.abs(target.y - newY);
                        if (dist < bestDist) {
                            bestDist = dist;
                            bestDir = dir;
                        }
                    }
                }

                ghost.x += bestDir.x;
                ghost.y += bestDir.y;
                ghost.direction = bestDir;
            }

            isWalkable(x, y) {
                if (x < 0 || x >= MAZE_WIDTH || y < 0 || y >= MAZE_HEIGHT) return false;
                return maze[y][x] !== '#';
            }

            checkDotCollision() {
                for (let i = this.dots.length - 1; i >= 0; i--) {
                    const dot = this.dots[i];
                    if (dot.x === this.pacman.x && dot.y === this.pacman.y) {
                        this.dots.splice(i, 1);
                        this.score += 10;
                        this.updateScore();
                        this.updateDotsDisplay();
                    }
                }

                for (let i = this.powerPellets.length - 1; i >= 0; i--) {
                    const pellet = this.powerPellets[i];
                    if (pellet.x === this.pacman.x && pellet.y === this.pacman.y) {
                        this.powerPellets.splice(i, 1);
                        this.score += 50;
                        this.powerMode = true;
                        this.powerTimer = 50;
                        this.updateScore();
                        this.updateDotsDisplay();
                    }
                }

                if (this.dots.length === 0 && this.powerPellets.length === 0) {
                    this.winGame();
                }
            }

            checkGhostCollision() {
                for (let i = this.ghosts.length - 1; i >= 0; i--) {
                    const ghost = this.ghosts[i];
                    if (ghost.x === this.pacman.x && ghost.y === this.pacman.y) {
                        if (this.powerMode) {
                            this.ghosts.splice(i, 1);
                            this.score += 200;
                            this.updateScore();
                        } else {
                            this.lives--;
                            this.updateLives();
                            
                            if (this.lives <= 0) {
                                this.endGame('üíÄ GAME OVER üíÄ');
                            } else {
                                this.pacman.x = 1;
                                this.pacman.y = 1;
                                this.pacman.direction = { x: 0, y: 0 };
                            }
                        }
                    }
                }
            }

            winGame() {
                const baseCoins = 7;
                const bonusCoins = Math.floor(this.score / 200);
                this.coins = baseCoins + bonusCoins;
                
                const data = getGameData();
                data.coins = (data.coins || 0) + this.coins;
                data.unlockedLevels = Math.max(data.unlockedLevels || 3, 4);
                localStorage.setItem('gameData', JSON.stringify(data));
                
                updateCoinsHeader();
                this.endGame('üéâ V√çTƒöZSTV√ç! üéâ');
            }

            updateScore() {
                document.getElementById('score').textContent = this.score;
            }

            updateDotsDisplay() {
                document.getElementById('dotsRemaining').textContent = 
                    `Dots: ${this.dots.length + this.powerPellets.length}`;
            }

            updateLives() {
                document.getElementById('lives').textContent = `‚ù§Ô∏è ≈Ωivoty: ${this.lives}`;
            }

            endGame(message) {
                this.gameOver = true;
                document.getElementById('gameOver').style.display = 'flex';
                document.getElementById('gameOverTitle').textContent = message;
                document.getElementById('gameOverScore').textContent = `Sk√≥re: ${this.score}`;
                document.getElementById('earnedCoins').textContent = this.coins;
                document.getElementById('coins').textContent = `ü™ô Mince: ${this.coins}`;
            }

            draw() {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Fialov√© zdi
                for (let y = 0; y < maze.length; y++) {
                    for (let x = 0; x < maze[y].length; x++) {
                        if (maze[y][x] === '#') {
                            const gradient = this.ctx.createLinearGradient(
                                x * TILE_SIZE, y * TILE_SIZE,
                                x * TILE_SIZE + TILE_SIZE, y * TILE_SIZE + TILE_SIZE
                            );
                            gradient.addColorStop(0, WALL_COLOR1);
                            gradient.addColorStop(0.5, WALL_COLOR2);
                            gradient.addColorStop(1, WALL_COLOR3);
                            
                            this.ctx.fillStyle = gradient;
                            this.ctx.fillRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                            
                            this.ctx.strokeStyle = '#6b21a8';
                            this.ctx.lineWidth = 1;
                            this.ctx.strokeRect(x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
                        }
                    }
                }

                // Dots
                this.ctx.fillStyle = '#ffb897';
                for (const dot of this.dots) {
                    this.ctx.beginPath();
                    this.ctx.arc(
                        dot.x * TILE_SIZE + TILE_SIZE / 2,
                        dot.y * TILE_SIZE + TILE_SIZE / 2,
                        2, 0, Math.PI * 2
                    );
                    this.ctx.fill();
                }

                // Power pellets
                const pelletSize = 5 + Math.sin(this.animationFrame * 0.2) * 1.5;
                this.ctx.fillStyle = this.powerMode ? '#00ff00' : '#fff';
                for (const pellet of this.powerPellets) {
                    this.ctx.beginPath();
                    this.ctx.arc(
                        pellet.x * TILE_SIZE + TILE_SIZE / 2,
                        pellet.y * TILE_SIZE + TILE_SIZE / 2,
                        pelletSize, 0, Math.PI * 2
                    );
                    this.ctx.fill();
                }

                // Pac-Man
                this.ctx.save();
                const pmCenterX = this.pacman.x * TILE_SIZE + TILE_SIZE / 2;
                const pmCenterY = this.pacman.y * TILE_SIZE + TILE_SIZE / 2;
                
                this.ctx.translate(pmCenterX, pmCenterY);
                
                let rotation = 0;
                if (this.pacman.direction.x === 1) rotation = 0;
                else if (this.pacman.direction.x === -1) rotation = Math.PI;
                else if (this.pacman.direction.y === -1) rotation = -Math.PI / 2;
                else if (this.pacman.direction.y === 1) rotation = Math.PI / 2;
                
                this.ctx.rotate(rotation);
                
                const pacGradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, TILE_SIZE / 2);
                pacGradient.addColorStop(0, '#FFFF00');
                pacGradient.addColorStop(0.7, '#FFDD00');
                pacGradient.addColorStop(1, '#FFB000');
                
                this.ctx.fillStyle = pacGradient;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, TILE_SIZE / 2 - 2, this.pacman.mouthAngle * Math.PI, (2 - this.pacman.mouthAngle) * Math.PI);
                this.ctx.lineTo(0, 0);
                this.ctx.fill();
                
                this.ctx.restore();

                // Duchov√©
                for (const ghost of this.ghosts) {
                    const gCenterX = ghost.x * TILE_SIZE + TILE_SIZE / 2;
                    const gCenterY = ghost.y * TILE_SIZE + TILE_SIZE / 2;
                    
                    const waveOffset = Math.sin((this.animationFrame + ghost.animOffset) * 0.3) * 2;
                    
                    this.ctx.fillStyle = this.powerMode ? '#0000ff' : ghost.color;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(gCenterX, gCenterY - 3 + waveOffset, TILE_SIZE / 2 - 2, Math.PI, 0);
                    
                    const bottomY = ghost.y * TILE_SIZE + TILE_SIZE - 2;
                    this.ctx.lineTo(ghost.x * TILE_SIZE + TILE_SIZE - 2, bottomY + waveOffset);
                    
                    for (let i = 0; i < 3; i++) {
                        const waveX = ghost.x * TILE_SIZE + TILE_SIZE - 2 - (i * (TILE_SIZE - 4) / 3);
                        const waveY = bottomY + waveOffset - (i % 2 === 0 ? 3 : 0);
                        this.ctx.lineTo(waveX, waveY);
                    }
                    
                    this.ctx.lineTo(ghost.x * TILE_SIZE + 2, bottomY + waveOffset);
                    this.ctx.closePath();
                    this.ctx.fill();

                    this.ctx.fillStyle = '#fff';
                    this.ctx.fillRect(ghost.x * TILE_SIZE + 6, ghost.y * TILE_SIZE + 8, 4, 4);
                    this.ctx.fillRect(ghost.x * TILE_SIZE + 15, ghost.y * TILE_SIZE + 8, 4, 4);
                    
                    this.ctx.fillStyle = '#000';
                    this.ctx.fillRect(ghost.x * TILE_SIZE + 7, ghost.y * TILE_SIZE + 9, 2, 2);
                    this.ctx.fillRect(ghost.x * TILE_SIZE + 16, ghost.y * TILE_SIZE + 9, 2, 2);
                }
            }
        }

        new Level3Game();
    </script>
</body>
</html>
